"""LaTeX utility functions for processing and manipulating LaTeX source code."""

import logging
import re
from pathlib import Path


def extract_definitions_and_usepackage_lines(latex_source: str) -> list[str]:
    """
    Extracts definitions and usepackage lines from LaTeX source
    """
    commands = ["\\def", "\\DeclareMathOperator", "\\DeclarePairedDelimiter"]
    packages_to_comment_out = [
        "amsthm",
        "color",
        "hyperref",
        "xcolor",
        "ragged2e",
        "times",
        "graphicx",
        "enumitem",
    ]
    extracted_lines = []

    lines = latex_source.split("\n")
    for line in lines:
        if any(line.strip().startswith(cmd) for cmd in commands):
            extracted_lines.append(line)
        if line.strip().startswith("\\usepackage"):
            # Skip packages that may conflict with Beamer
            if any(pkg in line for pkg in packages_to_comment_out):
                extracted_lines.append("% " + line)
            else:
                extracted_lines.append(line)
    return extracted_lines


def build_additional_tex(defs_and_pkgs: list[str]) -> str:
    """
    Build ADDITIONAL.tex contents from extracted lines.
    """
    header = [
        "% Auto-generated by paper2slides",
        "% This file aggregates definitions and package imports from the paper.",
    ]
    return "\n".join(header + defs_and_pkgs)


def save_additional_tex(contents: str, dest_dir: str) -> None:
    """Save ADDITIONAL.tex file to the specified directory."""
    path = Path(dest_dir) / "ADDITIONAL.tex"
    Path(dest_dir).mkdir(parents=True, exist_ok=True)
    with open(path, "w", encoding="utf-8") as f:
        f.write(contents)


def save_latex_source(latex_source: str, dest_dir: str) -> None:
    """
    Save the original LaTeX source to a file for later reference during editing.
    
    Args:
        latex_source: The LaTeX source content
        dest_dir: Directory to save the file (e.g., "source/2302.11553/")
    """
    path = Path(dest_dir) / "ORIGINAL_PAPER.tex"
    Path(dest_dir).mkdir(parents=True, exist_ok=True)
    try:
        with open(path, "w", encoding="utf-8") as f:
            f.write(latex_source)
        logging.info(f"Saved original paper LaTeX source to {path}")
    except Exception as e:
        logging.warning(f"Failed to save original LaTeX source: {e}")


def load_latex_source(source_dir: str) -> str:
    """
    Load the original LaTeX source from the saved file.
    
    Args:
        source_dir: Directory containing the saved file (e.g., "source/2302.11553/")
        
    Returns:
        LaTeX source content, or empty string if not available
    """
    path = Path(source_dir) / "ORIGINAL_PAPER.tex"
    if path.exists():
        try:
            with open(path, "r", encoding="utf-8", errors="ignore") as f:
                return f.read()
        except Exception as e:
            logging.warning(f"Failed to load original LaTeX source: {e}")
    return ""


def add_additional_tex(content: str) -> str:
    r"""
    Ensure that \input{ADDITIONAL.tex} is present. If missing, add near the top after documentclass.
    """
    if not content:
        return content
    if "\\input{ADDITIONAL.tex}" in content:
        return content
    # Insert after documentclass line
    pattern = re.compile(
        r"(\\documentclass\[[^\]]*\]\{beamer\}|\\documentclass\{beamer\})"
    )

    def _inserter(m: re.Match) -> str:
        return m.group(1) + "\n\\input{ADDITIONAL.tex}"

    new_content, count = pattern.subn(_inserter, content, count=1)
    if count == 0:
        logging.warning("\\input{ADDITIONAL.tex} is missing. Added manually.")
        return "\\input{ADDITIONAL.tex}\n" + content
    return new_content


def sanitize_frametitles(beamer_code: str) -> str:
    """
    Escapes unescaped ampersands inside \frametitle and its arguments.
    Also sanitizes titles provided via \begin{frame}{...} with optional [options].
    Handles <...>, [...], and {...} arguments with optional whitespace.
    """
    if not beamer_code:
        return ""

    # 1) Sanitize titles in \begin{frame}[opts]{Title}
    def repl_frame(match):
        begin_frame = match.group(1)
        options = match.group(2) or ""
        title = match.group(3)
        sanitized_options = re.sub(r"(?<!\\)&", r"\\&", options)
        sanitized_title = re.sub(r"(?<!\\)&", r"\\&", title)
        return f"{begin_frame}{sanitized_options}{{{sanitized_title}}}"

    pattern_frame = re.compile(r"(\\begin\{frame\})\s*(\[[^\]]*\])?\s*\{([^}]*)\}")
    beamer_code = pattern_frame.sub(repl_frame, beamer_code)

    # 2) Sanitize explicit \frametitle commands
    def repl(match):
        # Groups: 1=\frametitle, 2=<...>, 3=[...], 4={...} content
        command = match.group(1)
        overlay = match.group(2) or ""
        short_title = match.group(3) or ""
        main_title = match.group(4)

        sanitized_overlay = re.sub(r"(?<!\\)&", r"\\&", overlay)
        sanitized_short_title = (
            re.sub(r"(?<!\\)&", r"\\&", short_title) if short_title else ""
        )
        sanitized_main_title = re.sub(r"(?<!\\)&", r"\\&", main_title)

        return f"{command}{sanitized_overlay}{sanitized_short_title}{{{sanitized_main_title}}}"

    pattern = re.compile(
        r"(\\frametitle)\s*(<[^>]*>)?\s*(\[[^\]]*\])?\s*\{(.*?)\}", re.DOTALL
    )

    return pattern.sub(repl, beamer_code)
