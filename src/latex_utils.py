"""LaTeX utility functions for processing and manipulating LaTeX source code."""

import logging
import re
from pathlib import Path


def extract_definitions_and_usepackage_lines(latex_source: str) -> list[str]:
    """
    Extracts definitions and usepackage lines from LaTeX source
    """
    commands = ["\\def", "\\DeclareMathOperator", "\\DeclarePairedDelimiter"]
    packages_to_comment_out = [
        "amsthm",
        "color",
        "hyperref",
        "xcolor",
        "ragged2e",
        "times",
        "graphicx",
        "enumitem",
    ]
    extracted_lines = []

    lines = latex_source.split("\n")
    for line in lines:
        if any(line.strip().startswith(cmd) for cmd in commands):
            extracted_lines.append(line)
        if line.strip().startswith("\\usepackage"):
            # Skip packages that may conflict with Beamer
            if any(pkg in line for pkg in packages_to_comment_out):
                extracted_lines.append("% " + line)
            else:
                extracted_lines.append(line)
    return extracted_lines


def build_additional_tex(defs_and_pkgs: list[str]) -> str:
    """
    Build ADDITIONAL.tex contents from extracted lines.
    """
    header = [
        "% Auto-generated by paper2slides",
        "% This file aggregates definitions and package imports from the paper.",
    ]
    return "\n".join(header + defs_and_pkgs)


def save_additional_tex(contents: str, dest_dir: str) -> None:
    """Save ADDITIONAL.tex file to the specified directory."""
    path = Path(dest_dir) / "ADDITIONAL.tex"
    Path(dest_dir).mkdir(parents=True, exist_ok=True)
    with open(path, "w", encoding="utf-8") as f:
        f.write(contents)


def save_latex_source(latex_source: str, dest_dir: str) -> None:
    """
    Save the original LaTeX source to a file for later reference during editing.
    
    Args:
        latex_source: The LaTeX source content
        dest_dir: Directory to save the file (e.g., "source/2302.11553/")
    """
    path = Path(dest_dir) / "ORIGINAL_PAPER.tex"
    Path(dest_dir).mkdir(parents=True, exist_ok=True)
    try:
        with open(path, "w", encoding="utf-8") as f:
            f.write(latex_source)
        logging.info(f"Saved original paper LaTeX source to {path}")
    except Exception as e:
        logging.warning(f"Failed to save original LaTeX source: {e}")


def load_latex_source(source_dir: str) -> str:
    """
    Load the original LaTeX source from the saved file.
    
    Args:
        source_dir: Directory containing the saved file (e.g., "source/2302.11553/")
        
    Returns:
        LaTeX source content, or empty string if not available
    """
    path = Path(source_dir) / "ORIGINAL_PAPER.tex"
    if path.exists():
        try:
            with open(path, "r", encoding="utf-8", errors="ignore") as f:
                return f.read()
        except Exception as e:
            logging.warning(f"Failed to load original LaTeX source: {e}")
    return ""


def add_additional_tex(content: str) -> str:
    r"""
    Ensure that \input{ADDITIONAL.tex} is present. If missing, add near the top after documentclass.
    """
    if not content:
        return content
    if "\\input{ADDITIONAL.tex}" in content:
        return content
    # Insert after documentclass line
    pattern = re.compile(
        r"(\\documentclass\[[^]]*]\{beamer}|\\documentclass\{beamer})"
    )

    def _inserter(m: re.Match) -> str:
        return m.group(1) + "\n\\input{ADDITIONAL.tex}"

    new_content, count = pattern.subn(_inserter, content, count=1)
    if count == 0:
        logging.warning("\\input{ADDITIONAL.tex} is missing. Added manually.")
        return "\\input{ADDITIONAL.tex}\n" + content
    return new_content


def sanitize_frametitles(beamer_code: str) -> str:
    """
    Escapes unescaped ampersands inside \frametitle and its arguments.
    Also sanitizes titles provided via \begin{frame}{...} with optional [options].
    Handles <...>, [...], and {...} arguments with optional whitespace.
    
    Additionally fixes common LaTeX syntax errors that LLMs tend to produce,
    such as \\end{frame> instead of \\end{frame}.
    
    Also ensures commonly needed packages are loaded (booktabs, multirow)
    and defines common math macros (\\bx, \\by) if not already defined.
    """
    if not beamer_code:
        return ""

    # Fix common LLM errors: \end{...> and \begin{...> where > should be }
    beamer_code = re.sub(r'\\end\{([^}]+)>', r'\\end{\1}', beamer_code)
    beamer_code = re.sub(r'\\begin\{([^}]+)>', r'\\begin{\1}', beamer_code)

    # Ensure commonly needed packages are loaded after \documentclass
    # These are often used by LLMs but not explicitly loaded
    packages_to_ensure = []
    
    # Check for booktabs commands (\toprule, \midrule, \bottomrule, \cmidrule)
    if re.search(r'\\(toprule|midrule|bottomrule|cmidrule)', beamer_code):
        if '\\usepackage{booktabs}' not in beamer_code and '\\usepackage[' not in beamer_code or 'booktabs' not in beamer_code:
            packages_to_ensure.append('\\usepackage{booktabs}')
    
    # Check for \multirow command
    if '\\multirow' in beamer_code:
        if '\\usepackage{multirow}' not in beamer_code:
            packages_to_ensure.append('\\usepackage{multirow}')
    
    # Check for \bx, \by (common bold vector macros) - define them if not present
    math_macros = []
    if '\\bx' in beamer_code and '\\newcommand{\\bx}' not in beamer_code and '\\def\\bx' not in beamer_code:
        math_macros.append('\\providecommand{\\bx}{\\mathbf{x}}')
    if '\\by' in beamer_code and '\\newcommand{\\by}' not in beamer_code and '\\def\\by' not in beamer_code:
        math_macros.append('\\providecommand{\\by}{\\mathbf{y}}')
    
    # Insert packages and macros after \documentclass line
    if packages_to_ensure or math_macros:
        additions = '\n'.join(packages_to_ensure + math_macros)
        # Find position after \documentclass{beamer} or \documentclass[...]{beamer}
        docclass_pattern = re.compile(r'(\\documentclass(?:\[[^\]]*\])?\{beamer\})')
        match = docclass_pattern.search(beamer_code)
        if match:
            insert_pos = match.end()
            beamer_code = beamer_code[:insert_pos] + '\n' + additions + beamer_code[insert_pos:]

    # 1) Sanitize titles in \begin{frame}[opts]{Title}
    def repl_frame(match):
        begin_frame = match.group(1)
        options = match.group(2) or ""
        title = match.group(3)
        sanitized_options = re.sub(r"(?<!\\)&", r"\\&", options)
        sanitized_title = re.sub(r"(?<!\\)&", r"\\&", title)
        return f"{begin_frame}{sanitized_options}{{{sanitized_title}}}"

    pattern_frame = re.compile(r"(\\begin\{frame})\s*(\[[^]]*])?\s*\{([^}]*)}")
    beamer_code = pattern_frame.sub(repl_frame, beamer_code)

    # 2) Sanitize explicit \frametitle commands
    def repl(match):
        # Groups: 1=\frametitle, 2=<...>, 3=[...], 4={...} content
        command = match.group(1)
        overlay = match.group(2) or ""
        short_title = match.group(3) or ""
        main_title = match.group(4)

        sanitized_overlay = re.sub(r"(?<!\\)&", r"\\&", overlay)
        sanitized_short_title = (
            re.sub(r"(?<!\\)&", r"\\&", short_title) if short_title else ""
        )
        sanitized_main_title = re.sub(r"(?<!\\)&", r"\\&", main_title)

        return f"{command}{sanitized_overlay}{sanitized_short_title}{{{sanitized_main_title}}}"

    pattern = re.compile(
        r"(\\frametitle)\s*(<[^>]*>)?\s*(\[[^]]*])?\s*\{(.*?)}", re.DOTALL
    )

    return pattern.sub(repl, beamer_code)
